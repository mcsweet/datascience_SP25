summarize(
sample_mean = mean(x),
sample_sd = sd(x)
)
df_data_norm %>%
bootstraps(., times = 1000)
## NOTE: No need to edit
df_data_norm %>%
bootstraps(., times = 1) %>%
# Pull out a single `splits` object
pull(splits) %>%
.[[1]] %>%
# Use analysis() to turn the split into a usable dataset
analysis()
## NOTE: No need to edit this setup
df_resample_norm <-
bootstraps(df_data_norm, times = 1000) %>%
mutate(df = map(splits, ~ analysis(.x)))
# Visualize the first 9 of the resamples
df_resample_norm %>%
slice(1:9) %>%
unnest(df) %>%
ggplot(aes(x)) +
geom_histogram() +
facet_wrap(~ id)
## NOTE: No need to edit this example
# Start with our dataset
df_demo <-
df_data_norm %>%
# Create the bootstrap resamplings
bootstraps(., times = 1000) %>%
# Finicky code: Compute an estimate for each resampling (`splits` column)
mutate(
# The `map_*` family of functions iterates a provided function over a column
sample_mean = map_dbl(
# Chosen column
splits,
# Function we provide (defined inline)
function(split_df) {
# First, we use `analysis()` to translate the split into usable data
split_df %>%
analysis() %>%
# Then, we carry out whatever analysis we want
summarize(sample_mean = mean(x)) %>%
# One last wrangling step
pull(sample_mean)
}
)
)
df_demo
## TASK: Adapt the code given in the previous chunk
df_q1 <-
df_data_norm %>%
# Create the bootstrap resamplings
bootstraps(., times = 1000) %>%
# Finicky code: Compute an estimate for each resampling (`splits` column)
mutate(
# The `map_*` family of functions iterates a provided function over a column
sample_sd = map_dbl(
# Chosen column
splits,
# Function we provide (defined inline)
function(split_df) {
# First, we use `analysis()` to translate the split into usable data
split_df %>%
analysis() %>%
# Then, we carry out whatever analysis we want
summarize(sample_sd = sd(x)) %>%
# One last wrangling step
pull(sample_sd)
}
)
)
df_q1
## NOTE: No need to change this!
assertthat::assert_that(
df_q1 %>%
mutate(
test_sd = map_dbl(splits, ~analysis(.) %>% summarize(s = sd(x)) %>% pull(s)),
test = test_sd == sample_sd
) %>%
pull(test) %>%
all()
)
print("Great job!")
## NOTE: No need to edit
df_q1 %>%
ggplot(aes(sample_sd)) +
geom_histogram()
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
# summarize(se = ?)
df_q2
## TASK: Adapt the code given in the previous chunk
df_q1 <-
df_data_norm %>%
# Create the bootstrap resamplings
bootstraps(., times = 1000) %>%
# Finicky code: Compute an estimate for each resampling (`splits` column)
mutate(
# The `map_*` family of functions iterates a provided function over a column
sample_sd = map_dbl(
# Chosen column
splits,
# Function we provide (defined inline)
function(split_df) {
# First, we use `analysis()` to translate the split into usable data
split_df %>%
analysis() %>%
# Then, we carry out whatever analysis we want
summarize(sample_sd = sd(x)) %>%
# One last wrangling step
pull(sample_sd)
}
)
)
df_q1
## NOTE: No need to change this!
assertthat::assert_that(
df_q1 %>%
mutate(
test_sd = map_dbl(splits, ~analysis(.) %>% summarize(s = sd(x)) %>% pull(s)),
test = test_sd == sample_sd
) %>%
pull(test) %>%
all()
)
print("Great job!")
## NOTE: No need to edit
df_q1 %>%
ggplot(aes(sample_sd)) +
geom_histogram()
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean))
df_q2
View(df_data_norm)
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(x)/lenght(x))
View(df_q2)
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
#summarize(se = sd(x)/lenght(x))
df_q2
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
#summarize(se = sd(x)/lenght(x))
df_q2
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
)
# TODO: Complete the following code
#summarize(se = sd(x)/lenght(x))
df_q2
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
#summarize(se = sd(sample_mean)/lenght(sample_mean))
df_q2
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean)/lenght(sample_mean))
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean)/length(sample_mean))
df_q2
## NOTE: No need to change this!
assertthat::assert_that(
(df_q2 %>% pull(se)) > 0.1,
msg = "Take a closer look at the definition of the standard error. We only divide by sqrt(n) when using the standard deviation of the *population* (not the standard deviation of the *samping distribution*)."
)
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean)/sqrt(length(sample_mean))
df_q2
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean)/sqrt(length(sample_mean)))
df_q2
## NOTE: No need to change this!
assertthat::assert_that(
(df_q2 %>% pull(se)) > 0.1,
msg = "Take a closer look at the definition of the standard error. We only divide by sqrt(n) when using the standard deviation of the *population* (not the standard deviation of the *samping distribution*)."
)
## NOTE: No need to change this!
assertthat::assert_that(
(df_q2 %>% pull(se)) > 0.1,
msg = "Take a closer look at the definition of the standard error. We only divide by sqrt(n) when using the standard deviation of the *population* (not the standard deviation of the *samping distribution*)."
)
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean)/sqrt(length(sample_mean)))
df_q2
## NOTE: No need to change this!
assertthat::assert_that(
(df_q2 %>% pull(se)) > 0.1,
msg = "Take a closer look at the definition of the standard error. We only divide by sqrt(n) when using the standard deviation of the *population* (not the standard deviation of the *samping distribution*)."
)
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean)/sqrt(length(sample_mean)))
df_q2
## NOTE: No need to change this!
assertthat::assert_that(
(df_q2 %>% pull(se)) > 0.1,
msg = "Take a closer look at the definition of the standard error. We only divide by sqrt(n) when using the standard deviation of the *population* (not the standard deviation of the *samping distribution*)."
)
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
)
# TODO: Complete the following code
#summarize(se = sd(sample_mean)/sqrt(length(sample_mean)))
df_q2
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean)/(length(sample_mean)))
df_q2
## NOTE: No need to change this!
assertthat::assert_that(
(df_q2 %>% pull(se)) > 0.1,
msg = "Take a closer look at the definition of the standard error. We only divide by sqrt(n) when using the standard deviation of the *population* (not the standard deviation of the *samping distribution*)."
)
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = (length(sample_mean)))
df_q2
## NOTE: No need to change this!
assertthat::assert_that(
(df_q2 %>% pull(se)) > 0.1,
msg = "Take a closer look at the definition of the standard error. We only divide by sqrt(n) when using the standard deviation of the *population* (not the standard deviation of the *samping distribution*)."
)
print("Great job!")
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(se = sd(sample_mean)/(length(sample_mean)))
df_q2
sd(sample_mean)
## TASK: Compute the standard error
df_q2 <-
df_data_norm %>%
bootstraps(., times = 1000) %>%
mutate(
sample_mean = map_dbl(
splits,
function(split_df) {
split_df %>%
analysis() %>%
summarize(sample_mean = mean(x)) %>%
pull(sample_mean)
}
)
) %>%
# TODO: Complete the following code
summarize(
se = sd(sample_mean)/(length(sample_mean)),
sd = sd(sample_mean)
)
df_q2
## TASK: Compute the lower and upper quantiles of the sampling distribution
alpha <- 0.01
df_q3 <-
df_demo %>%
summarize(
# task_begin
mean_lo = quantile(probs = c(alpha/2)),
mean_up = quantile(probs = c(1-alpha/2)),
# task_end
)
## TASK: Compute the lower and upper quantiles of the sampling distribution
alpha <- 0.01
df_q3 <-
df_demo %>%
summarize(
# task_begin
mean_lo = quantile(.,probs = c(alpha/2)),
mean_up = quantile(.,probs = c(1-alpha/2)),
# task_end
)
